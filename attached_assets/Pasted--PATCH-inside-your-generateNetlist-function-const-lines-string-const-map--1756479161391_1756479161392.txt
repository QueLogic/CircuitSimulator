// --- PATCH: inside your generateNetlist(...) function ---
const lines: string[] = [];
const map: NetToNodeMap = Object.create(null);

// Reserve ground node 0 explicitly.
map["0"] = 0;

function touchNet(netName: string): number {
  const n = normalizeNet(netName);
  if (!n) return 0;
  if (map[n] != null) return map[n];
  // Node numbers start from 1 (0 is ground). We allocate densely.
  const next = Math.max(...Object.values(map)) + 1;
  map[n] = next;
  return next;
}

function netsOf(...names: Array<string | undefined>) {
  // returns node numbers in order, touching the map
  return names.map(n => touchNet(n || ""));
}

// Emit helper for each element type you support
function emitRes(ref: string, netA: string, netB: string, value: string | number) {
  const [a, b] = netsOf(netA, netB);
  const ohms = parseValue(String(value), 1000);
  lines.push(`R${ref} ${a} ${b} ${ohms}`);
}

function emitCap(ref: string, netA: string, netB: string, value: string | number) {
  const [a, b] = netsOf(netA, netB);
  const farads = parseValue(String(value), 1e-6);
  lines.push(`C${ref} ${a} ${b} ${farads}`);
}

function emitBjtNpn(ref: string, c: string, b: string, e: string, model = "BC549") {
  const [nc, nb, ne] = netsOf(c, b, e);
  lines.push(`Q${ref} ${nc} ${nb} ${ne} ${model}`);
}

// ...repeat emitters for diodes, voltage sources, etc.

// During component iteration:
for (const comp of components) {
  if (DISPLAY_ONLY_TYPES.has(comp.type)) {
    // Skip display components entirely (no mapping, no emission).
    continue;
  }

  try {
    switch (comp.type) {
      case "resistor":
        emitRes(comp.ref ?? "X", comp.netA, comp.netB, comp.value);
        break;
      case "capacitor":
        emitCap(comp.ref ?? "X", comp.netA, comp.netB, comp.value);
        break;
      case "bjt-npn":
      case "transistor-npn":
        // Assume your schema uses comp.collector / comp.base / comp.emitter OR pins[]
        emitBjtNpn(
          comp.ref ?? "X",
          comp.collector ?? comp.pins?.C,
          comp.base ?? comp.pins?.B,      // <-- Q4B must be here
          comp.emitter ?? comp.pins?.E,
          comp.model ?? "BC549"
        );
        break;
      // ... other supported types
      default:
        // Optional: log once per type
        debug && console.warn(`[SPICE] Skipping unsupported type: ${comp.type}`);
        break;
    }
  } catch (e) {
    console.error(`[SPICE] Failed to emit ${comp.ref || comp.type}:`, e);
  }
}

// Finalize: models, control block, etc.
lines.unshift(`* Auto-generated by simple-spice.ts`);
// Ensure you add .model lines before .end
// lines.push(`.model BC549 NPN ( ... )`);
lines.push(`.end`);

// --- Invariants & debug aids ---
if (debug) {
  const usedNodeNums = new Set<string>();
  for (const ln of lines) {
    const m = ln.match(/\b\d+\b/g);
    if (m) m.forEach(s => usedNodeNums.add(s));
  }
  const known = new Set(Object.values(map).map(String));
  const diffA = [...usedNodeNums].filter(n => !known.has(n));
  const diffB = [...known].filter(n => !usedNodeNums.has(n));

  if (diffA.length || diffB.length) {
    console.warn("[SPICE] node set mismatch: used-but-unmapped=", diffA, "mapped-but-unused=", diffB);
  }

  console.info("[SPICE] netToNodeMap:", map);
  console.info("[SPICE] First 30 lines:\n", lines.slice(0, 30).join("\n"));
}

// write out `lines.join("\n")` to /tmp/.../circuit.cir and return { netToNodeMap: map, ... }
